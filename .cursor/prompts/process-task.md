# Обработка задачи для проекта tasks-solutions

Ты помогаешь обработать файл с алгоритмической задачей и привести его к стандартам проекта.

## Задача

Проанализируй предоставленный файл с задачей и выполни следующие действия:

1. **Определи категорию задачи** и правильную папку для размещения:
   - `easy-top-50/` — задачи из топ-50 легких LeetCode
   - `sliding-window/` — задачи на скользящее окно
   - `binary-search/` — задачи на бинарный поиск
   - `graph/` — задачи на графы
   - `javascript/` — задачи по JavaScript (LeetCode JavaScript challenges)
   - `yandex/` — задачи от Яндекса
   - Корень `tasks/` — прочие задачи

2. **Очисти код от всего лишнего**:
   - Удали все `console.log`, `console.error`, `debugger`
   - Удали неиспользуемые импорты и переменные
   - Удали закомментированный код (кроме альтернативных решений, которые показывают разные подходы)
   - Удали отладочный код и временные переменные

3. **Добавь структуру согласно стандартам проекта**:

   **a) Ссылка на оригинал** (если есть):
   ```javascript
   // https://leetcode.com/problems/task-name/description/
   ```

   **b) JSDoc комментарий** с описанием:
   ```javascript
   /**
    * Краткое описание задачи
    *
    * Задача: Подробное описание задачи и требований.
    *
    * Подход: Описание используемого подхода/алгоритма.
    *
    * Паттерны: #arrays, #hashtable
    * Сложность: O(n)
    */
   ```

   **c) Теги паттернов** (укажи релевантные):
   - `#arrays` — задачи про массивы
   - `#strings` — задачи про строки
   - `#hashtable` — использование хеш-таблиц
   - `#two_pointers` — задачи с двумя указателями
   - `#sliding_window` — скользящее окно
   - `#binary_search` — бинарный поиск
   - `#tree` — задачи на деревья
   - `#graph` — задачи на графы
   - `#dfs` / `#bfs` — обход дерева/графа
   - `#dynamic` — динамическое программирование
   - `#in_place` — трансформация на месте
   - `#linked_list` — связанные списки
   - `#stack` / `#queue` — стек/очередь
   - `#matrix` — задачи про матрицы
   - `#naive` — решение "в лоб"

   **d) Комментарии в коде**:
   - Добавь комментарии на русском языке, объясняющие логику решения
   - Оставь закомментированные альтернативные решения, если они демонстрируют разные подходы (например, O(n²) vs O(n))

4. **Напиши тесты**:
   - Используй `vitest`: `import { expect, test } from "vitest";`
   - Покрой основные случаи
   - Добавь edge cases (пустые массивы, граничные значения, отрицательные числа и т.д.)
   - Название теста должно быть понятным (например, `test("twoSum", () => { ... })`)

5. **Переименуй файл**:
   - Формат: `{номер}. {Название}.test.js` (если есть номер LeetCode) или `{Название}.test.js`
   - Примеры: `146. LRU Cache.test.js`, `Two Sum.test.js`

6. **Перемести файл** в правильную папку согласно категории

## Примеры правильного оформления

### Пример 1: Two Sum
```javascript
// https://leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/546/

/**
 * Найти два числа, сумма которых равна target
 *
 * Задача: Найти индексы двух чисел в массиве, сумма которых равна target.
 * Каждый вход имеет ровно одно решение, нельзя использовать один элемент дважды.
 *
 * Паттерны: #arrays, #hashtable
 */

import { expect, test } from "vitest";

var twoSum = function (nums, target) {
  // O (n^2)
  // for (let i = 0; i < nums.length; i++) {
  //   for (let j = i + 1; j < nums.length; j++) {
  //     if (nums[i] + nums[j] === target) {
  //       return [i, j];
  //     }
  //   }
  // }

  const map = new Map();

  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i];
    }

    map.set(nums[i], i);
  }
};

test("twoSum", () => {
  expect(twoSum([3, 3], 6)).toEqual([0, 1]);
  expect(twoSum([2, 7, 11, 15], 9)).toEqual([0, 1]);
  expect(twoSum([3, 2, 4], 6)).toEqual([1, 2]);
  expect(twoSum([0, 0, 0, 0, 10, 0, 0, 0, 0, 10], 20)).toEqual([4, 9]);
  expect(twoSum([-3, 4, 3, 90], 0)).toEqual([0, 2]);
  expect(twoSum([20, 20, 4, 4, 2, 2], 4)).toEqual([4, 5]);
});
```

### Пример 2: LRU Cache
```javascript
// https://leetcode.com/problems/lru-cache/description/

/**
 * LRU Cache (Least Recently Used Cache)
 *
 * Задача: Реализовать структуру данных LRU Cache, которая поддерживает операции get и put.
 * LRU (Least Recently Used) - алгоритм кэширования, при котором удаляется наименее используемый элемент.
 *
 * Подход:
 * Используется комбинация двунаправленного связанного списка и хеш-таблицы (Map):
 * - Связанный список хранит элементы в порядке использования (head - самый старый, tail - самый новый)
 * - Map обеспечивает O(1) доступ к узлам по ключу
 *
 * Паттерны: #hashtable, #linked_list
 * Сложность: get и put - O(1)
 */

import { expect, test } from "vitest";

// ... код реализации ...

test("LRU Cache", () => {
  const lru = new LRUCache(2);
  // ... тесты ...
});
```

## Важные правила

1. **Всегда используй русский язык** для комментариев и описаний
2. **Теги должны быть в формате** `#tag_name` (с решеткой, без пробелов)
3. **Сложность указывай** в формате O(n), O(n²), O(log n) и т.д.
4. **Если задача из LeetCode**, обязательно укажи номер в начале названия файла
5. **Тесты должны быть полными** — покрывай не только happy path, но и edge cases
6. **Код должен быть чистым** — никаких отладочных логов или неиспользуемого кода

## Алгоритм работы

1. Прочитай предоставленный файл
2. Определи тип задачи и категорию
3. Очисти код от всего лишнего
4. Добавь структуру (ссылка, JSDoc, теги, комментарии)
5. Напиши тесты
6. Переименуй файл в правильный формат
7. Перемести файл в нужную папку

Начни обработку файла!
