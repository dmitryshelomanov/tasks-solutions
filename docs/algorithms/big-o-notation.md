# Big O нотация: Анализ сложности алгоритмов

## Полезные ресурсы

- [Статья на Habr о Big O](https://habr.com/ru/articles/782608/)

## Что такое Big O?

**Big O** — это термин из области анализа сложности алгоритмов и структур данных в информатике. Он используется для оценки верхней границы (наихудшего случая) временной сложности алгоритма.

### Простыми словами

**Big O** показывает, как будет меняться производительность алгоритма в зависимости от роста входящих данных.

Если мы будем увеличивать количество входящих данных, то у нас может расти:
- Количество операций
- Время выполнения алгоритма
- Количество памяти, используемой алгоритмом

**Big O** показывает скорость роста времени исполнения алгоритма при увеличении размера входных данных.

### Почему называется Big O?

В математике "O" используется для обозначения "order of" (порядка) и позволяет сравнивать функции роста. Он представляет собой математическую нотацию, которая описывает, как алгоритм будет выполняться в наихудшем случае, исходя из размера входных данных.

---

## Основные нотации Big O (от лучшего к худшему)

### O(1) — Константная сложность

**Описание**: Время выполнения алгоритма **не зависит** от размера входных данных.

**Примеры**:
- Доступ к элементу массива по индексу
- Вставка/удаление в начале связанного списка
- Получение размера массива

**Код**:
```javascript
function getFirstElement(arr) {
  return arr[0]; // O(1) — одна операция
}

function insertAtHead(list, value) {
  list.head = { value, next: list.head }; // O(1)
}
```

**График**: Горизонтальная линия (не растёт)

---

### O(log n) — Логарифмическая сложность

**Описание**: Время выполнения алгоритма растёт **медленно** с увеличением размера входных данных. При удвоении размера данных количество операций увеличивается на константу.

**Примеры**:
- Бинарный поиск в отсортированном массиве
- Поиск в сбалансированном бинарном дереве поиска
- Деление пополам на каждой итерации

**Код**:
```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
// O(log n) — каждый раз делим массив пополам
```

**График**: Медленно растущая кривая

---

### O(n) — Линейная сложность

**Описание**: Время выполнения алгоритма **пропорционально** размеру входных данных.

**Примеры**:
- Просмотр всех элементов в массиве
- Поиск элемента в неотсортированном массиве
- Обход связанного списка

**Код**:
```javascript
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
  }
  return max;
}
// O(n) — проходим по всем элементам один раз
```

**График**: Прямая линия под углом 45°

---

### O(n log n) — Линейно-логарифмическая сложность

**Описание**: Время выполнения растёт быстрее, чем линейно, но медленнее, чем квадратично. Очень распространено в эффективных алгоритмах сортировки.

**Примеры**:
- Сортировка слиянием (merge sort)
- Быстрая сортировка (quick sort) — средний случай
- Пирамидальная сортировка (heap sort)

**Код**:
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));  // O(log n) уровней
  const right = mergeSort(arr.slice(mid));    // O(n) операций на каждом
  
  return merge(left, right); // O(n) на слияние
}
// O(n log n) — делим на log n уровней, на каждом уровне O(n) операций
```

**График**: Кривая между O(n) и O(n²)

---

### O(n²) — Квадратичная сложность

**Описание**: Время выполнения зависит от **квадрата** размера входных данных. Обычно возникает при вложенных циклах.

**Примеры**:
- Сортировка пузырьком (bubble sort)
- Сортировка выбором (selection sort)
- Сортировка вставками (insertion sort)
- Проверка всех пар элементов

**Код**:
```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {      // n итераций
    for (let j = 0; j < arr.length - i - 1; j++) { // n итераций
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
// O(n²) — для каждого элемента проверяем все остальные
```

**График**: Парабола

---

### O(n³) — Кубическая сложность

**Описание**: Время выполнения зависит от **куба** размера входных данных. Обычно при трёх вложенных циклах.

**Примеры**:
- Алгоритмы с тремя вложенными циклами
- Некоторые алгоритмы многомерной обработки данных
- Перемножение матриц наивным способом

**Код**:
```javascript
function findTriplets(arr) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      for (let k = j + 1; k < arr.length; k++) {
        if (arr[i] + arr[j] + arr[k] === 0) {
          result.push([arr[i], arr[j], arr[k]]);
        }
      }
    }
  }
  return result;
}
// O(n³) — три вложенных цикла
```

**График**: Резко растущая кривая

---

### O(2^n) — Экспоненциальная сложность

**Описание**: Время выполнения **удваивается** с каждым новым элементом. Очень неэффективно.

**Примеры**:
- Рекурсивный расчёт чисел Фибоначчи (наивный)
- Генерация всех подмножеств
- Некоторые задачи перебора

**Код**:
```javascript
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
// O(2^n) — на каждом уровне количество вызовов удваивается
```

**График**: Экспоненциально растущая кривая

---

### O(n!) — Факториальная сложность

**Описание**: Самая высокая степень роста. Время выполнения растёт **факториально** от размера входных данных. Чрезвычайно неэффективно для больших значений n.

**Примеры**:
- Перебор всех возможных перестановок
- Решение задачи коммивояжёра наивным способом
- Генерация всех возможных комбинаций

**Код**:
```javascript
function permutations(arr) {
  if (arr.length <= 1) return [arr];
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
    const perms = permutations(rest);
    for (const perm of perms) {
      result.push([arr[i], ...perm]);
    }
  }
  return result;
}
// O(n!) — для каждого элемента генерируем (n-1)! перестановок
```

**График**: Очень круто растущая кривая

---

## Сравнение сложностей

| Нотация | Название | Пример для n=10 | Пример для n=100 |
|---------|----------|-----------------|------------------|
| O(1) | Константная | 1 | 1 |
| O(log n) | Логарифмическая | ~3 | ~7 |
| O(n) | Линейная | 10 | 100 |
| O(n log n) | Линейно-логарифмическая | ~33 | ~664 |
| O(n²) | Квадратичная | 100 | 10,000 |
| O(n³) | Кубическая | 1,000 | 1,000,000 |
| O(2^n) | Экспоненциальная | 1,024 | 1.27 × 10³⁰ |
| O(n!) | Факториальная | 3,628,800 | 9.33 × 10¹⁵⁷ |

---

## Пространственная сложность

**Пространственная сложность** (Space Complexity) описывает, сколько дополнительной памяти использует алгоритм относительно размера входных данных.

### Примеры

```javascript
// O(1) пространственная сложность
function sum(arr) {
  let total = 0; // Константная память
  for (const num of arr) {
    total += num;
  }
  return total;
}

// O(n) пространственная сложность
function copyArray(arr) {
  const copy = []; // Память пропорциональна n
  for (const num of arr) {
    copy.push(num);
  }
  return copy;
}

// O(n) пространственная сложность (рекурсия)
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // n вызовов в стеке
}
```

---

## Практические примеры по темам

### Скользящее окно

**Временная сложность**: O(n × k), где k — размер окна
- В худшем случае, если валидация окна занимает O(k) времени
- Если валидация O(1), то общая сложность O(n)

**Пример**:
```javascript
// Поиск максимальной суммы подмассива размера k
function maxSumSubarray(arr, k) {
  let maxSum = 0;
  // Инициализация окна: O(k)
  for (let i = 0; i < k; i++) {
    maxSum += arr[i];
  }
  
  let windowSum = maxSum;
  // Скольжение: O(n-k) ≈ O(n)
  for (let i = k; i < arr.length; i++) {
    windowSum = windowSum - arr[i - k] + arr[i];
    maxSum = Math.max(maxSum, windowSum);
  }
  
  return maxSum;
}
// Общая сложность: O(k) + O(n) = O(n)
```

---

## Правила упрощения Big O

1. **Игнорируйте константы**: O(2n) → O(n), O(5) → O(1)
2. **Оставляйте только доминирующий член**: O(n² + n) → O(n²)
3. **Разные входные данные = разные переменные**: O(a × b), если a и b независимы
4. **Сложение vs умножение**:
   - Последовательные операции: складываем — O(a + b)
   - Вложенные операции: умножаем — O(a × b)

---

## Важные замечания

1. **Big O описывает худший случай** — в реальности алгоритм может работать быстрее
2. **Константы важны** — O(100n) медленнее O(n), но оба O(n)
3. **Большие данные** — для маленьких n разница может быть незаметна
4. **Практика важна** — иногда O(n²) может быть быстрее O(n log n) для маленьких n из-за констант

---

*Для более глубокого изучения см. [Паттерны решения задач](./algorithm-patterns.md) с примерами алгоритмов*
