# Как работает браузер

Краткая выжимка: что происходит от ввода URL до отображения страницы на экране.

**Источники:**

- [Часть 1: навигация и получение данных](https://habr.com/ru/companies/kts/articles/669784/)
- [Часть 2: парсинг и выполнение JS](https://habr.com/ru/companies/kts/articles/678034/)
- [Часть 3: деревья специальных возможностей и рендеринга](https://habr.com/ru/companies/kts/articles/683240/)

---

## Общая схема

1. **Навигация** — пользователь запрашивает страницу (ссылка, адресная строка, форма).
2. **Получение данных** — браузер запрашивает HTML (и позже CSS/JS/картинки) по HTTP(S).
3. **Парсинг** — разбор HTML → DOM, CSS → CSSOM, JS → выполнение.
4. **Рендеринг** — объединение DOM и CSSOM, расчёт макета, отрисовка пикселей.

Ниже — выжимки по каждому этапу.

---

## Часть 1: Навигация и получение данных

### Навигация

**DNS (разрешение домена)**  
Браузеру нужен IP-адрес сервера. Домен (например, `example.com`) по запросу преобразуется в IP через DNS-серверы. Результат часто кэшируется, поэтому повторные заходы на тот же сайт быстрее.

**TCP (установка соединения)**  
По IP браузер устанавливает соединение с сервером по протоколу TCP — через «трёхрукопожатие» (SYN → SYN-ACK → ACK). После этого канал готов к обмену данными.

**TLS (для HTTPS)**  
Для защищённого соединения идут переговоры TLS: согласование шифра, проверка сертификата сервера, обмен ключами. После этого трафик шифруется, и по каналу можно слать HTTP-запросы.

### Получение данных

**HTTP-запрос**  
Браузер отправляет первый запрос (обычно GET) за HTML-документом. В запросе указываются метод, URI, заголовки.

**HTTP-ответ**  
Сервер возвращает код состояния (200 = успех), заголовки и тело — в том числе HTML. Остальные ресурсы (CSS, JS, изображения) запрашиваются позже, когда парсер до них доходит.

**TTFB (Time to First Byte)**  
Время от начала запроса до получения первого байта ответа. Первый пакет HTML часто около 14 КБ — этого достаточно, чтобы начать парсинг.

**Медленный старт TCP**  
Скорость передачи в начале ограничена: объём данных понемногу увеличивается, пока не подстроится под пропускную способность. Это снижает потери пакетов и перегрузку сети.

---

## Часть 2: Парсинг HTML/CSS и выполнение JS

### Парсинг HTML

**Роль браузерного движка**  
Движок (Blink, WebKit, Gecko) разбирает HTML и CSS, строит структуры данных и рисует страницу. Он же решает, что интерактивно. Это не отдельная программа, а часть браузера.

**Токенизация**  
Исходный HTML превращается в поток токенов: теги (открывающие/закрывающие), атрибуты, текст, комментарии и т.д. Аналогия: разбиение текста на слова.

**Построение DOM**  
По токенам строится дерево — DOM (Document Object Model). Корень — `<html>`, узлы — элементы, вложенность отражает структуру документа. Чем больше узлов, тем дольше построение DOM.

**Блокирующие ресурсы**  
Встречая блокирующий ресурс (например, CSS в `<head>` или синхронный `<script>`), парсер останавливается до его загрузки и выполнения. Поэтому скрипты часто кладут в конец `<body>` или используют `defer`/`async`.

**Предзагрузчики (Preload Scanner)**  
Пока основной парсер ждёт скрипт, лёгкий парсер просматривает остальной HTML и запускает загрузку нужных ресурсов (CSS, JS, шрифты) заранее. К моменту, когда до них дойдёт основной парсер, они могут уже быть в кэше.

### Парсинг CSS

**CSSOM**  
CSS (внешние файлы и `<style>`) разбирается в дерево — CSSOM (объектная модель CSS). Оно нужно для стилизации и, как и построение DOM, блокирует рендеринг.

**Токенизация и дерево**  
Байты → символы → токены → узлы → CSSOM. Браузер сопоставляет правила с элементами (селекторное согласование), учитывая каскад и специфичность. Правила читаются справа налево (например, в `section p` сначала ищутся все `p`, потом проверяется родитель `section`).

### Выполнение JavaScript

**JS-движки**  
Код выполняют движки: V8 (Chrome, Node.js), SpiderMonkey (Firefox), JavaScriptCore (Safari), в старых Edge — Chakra. Они парсят JS, компилируют и выполняют.

**От интерпретации к JIT**  
Раньше JS в основном интерпретировался (строка за строкой). Современные движки используют **JIT (Just-In-Time)** компиляцию: код преобразуется в машинный во время выполнения, с оптимизациями под текущую машину.

**Обработка кода**  
Исходный код разбирается в **AST (абстрактное синтаксическое дерево)** — структуру из узлов (объявления, вызовы, выражения). AST затем компилируется в машинный код и выполняется. Для отслеживания вызовов используется **стек вызовов (Call Stack)**.

Подробнее про движки и их взаимодействие см. **[JS-движки и браузерные движки](./js-and-browser-engines.md)**.

---

## Часть 3: Дерево доступности и рендеринг

### Дерево специальных возможностей (Accessibility Tree, A11y)

Вспомогательные технологии (скринридеры, лупа, голосовое управление) не читают DOM напрямую. Браузер строит **дерево доступности** — семантическую версию DOM, которая обновляется вместе с DOM. У элементов, важных для доступности, есть узлы в этом дереве. Семантическая разметка HTML улучшает доступность и корректную работу скринридеров.

В Chrome дерево можно посмотреть: DevTools → вкладка **Elements** → панель **Accessibility** справа.

### Дерево рендеринга и отрисовка

**Объединение DOM и CSSOM**  
Браузер обходит DOM и для каждого **видимого** узла подбирает правила из CSSOM (скрытые, например `display: none`, и служебные узлы вроде `<script>` не попадают в дерево рендеринга). Получается дерево рендеринга с узлами и их вычисленными стилями.

**Layout (компоновка / reflow)**  
По дереву рендеринга вычисляются **размеры и положение** каждого элемента в viewport. Это делается не один раз: при изменении DOM, размера окна, размеров/позиции элементов пересчёт выполняется снова. Операции layout дорогие, особенно на слабых устройствах.

**Paint (раскрашивание)**  
Когда позиции известны, браузер рисует пиксели — цвет, границы, тени, текст, изображения. Paint тоже перезапускается при изменении визуала (цвет, фон, тень, видимость и т.д.).

**Слои и композитинг**  
Страница может быть разбита на **слои**. Слои рисуются отдельно (в том числе на GPU), затем совмещаются в финальную картинку (композитинг). Это ускоряет перерисовку: при изменении одного элемента не нужно перерисовывать всю страницу. Отдельный слой часто получают элементы с `transform`, `opacity`, `<video>`, `<canvas>`, а также при использовании `will-change`. Композитинг обрабатывается в отдельном потоке и может задействовать GPU.

---

## Связь с другими документами

| Тема | Документ |
|------|----------|
| JS-движки, браузерные движки, DOM/CSSOM/Render Tree | [JS-движки и браузерные движки](./js-and-browser-engines.md) |
| Оптимизация загрузки и первого отображения | [Критический путь рендеринга](./critical-rendering-path.md) |
| Асинхронность и очередь задач в браузере | [Event Loop в JavaScript](../javascript/event-loop.md) |

---

*Источники: цикл «Как работают браузеры» (KTS / Habr), перевод статей Arika O.*
