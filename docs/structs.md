# Основные структуры данных

## Полезные ссылки

- [10 основных структур данных](https://practicum.yandex.ru/blog/10-osnovnyh-struktur-dannyh/)
- [Статья на Habr о структурах данных](https://habr.com/ru/articles/422259/)

## Введение

Структуры данных — это способы организации и хранения данных в памяти компьютера для эффективного доступа и модификации. Выбор правильной структуры данных критически важен для производительности алгоритмов.

---

## 1. Array (Массив)

### Описание

Массив — это линейная структура данных, которая хранит элементы в непрерывной области памяти. В JavaScript массивы динамические и могут содержать элементы разных типов.

### Операции и сложность

| Операция | Время | Описание |
|----------|-------|----------|
| Доступ по индексу | O(1) | Прямой доступ к элементу |
| Поиск | O(n) | Нужно проверить все элементы |
| Вставка в начало | O(n) | Нужно сдвинуть все элементы |
| Вставка в конец | O(1) | Просто добавляем элемент |
| Удаление из начала | O(n) | Нужно сдвинуть все элементы |
| Удаление с конца | O(1) | Просто удаляем элемент |

### Пример

```javascript
const arr = [1, 2, 3, 4, 5];

// Доступ
arr[0];  // O(1)

// Поиск
arr.indexOf(3);  // O(n)

// Добавление
arr.push(6);     // O(1)
arr.unshift(0);  // O(n)

// Удаление
arr.pop();       // O(1)
arr.shift();     // O(n)
```

---

## 2. Linked List (Связный список)

### Описание

Связный список — это линейная структура данных, где элементы хранятся в узлах, каждый из которых содержит данные и ссылку на следующий узел. В отличие от массива, элементы не хранятся в непрерывной памяти.

### Типы связных списков

- **Односвязный список** — каждый узел ссылается только на следующий
- **Двусвязный список** — каждый узел ссылается на следующий и предыдущий
- **Кольцевой список** — последний узел ссылается на первый

### Операции и сложность

| Операция | Время | Память | Описание |
|----------|-------|--------|----------|
| Вставка в начало | O(1) | O(1) | Обновление указателей |
| Вставка в конец | O(n) | O(1) | Нужно найти последний узел |
| Вставка в позицию | O(n) | O(1) | Обход до нужной позиции |
| Удаление с начала | O(1) | O(1) | Обновление указателей |
| Удаление с конца | O(n) | O(1) | Нужно найти предпоследний узел |
| Удаление по позиции | O(n) | O(1) | Обход до нужной позиции |
| Поиск | O(n) | O(1) | Обход по списку |

### Пример реализации

```javascript
class ListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }
  
  // Вставка в начало: O(1)
  prepend(value) {
    const newNode = new ListNode(value);
    newNode.next = this.head;
    this.head = newNode;
  }
  
  // Поиск: O(n)
  find(value) {
    let current = this.head;
    while (current) {
      if (current.value === value) return current;
      current = current.next;
    }
    return null;
  }
}
```

---

## 3. Stack (Стек)

### Описание

Стек — это линейная структура данных, работающая по принципу **LIFO (Last In, First Out)** — последний пришёл, первый ушёл. Как стопка тарелок: можно добавлять и убирать только сверху.

### Операции

- **push()** — добавить элемент наверх
- **pop()** — удалить элемент сверху
- **peek()** / **top()** — посмотреть верхний элемент
- **isEmpty()** — проверить, пуст ли стек

### Операции и сложность

| Операция | Время | Память | Описание |
|----------|-------|--------|----------|
| push | O(1) | O(1) | Добавление наверх |
| pop | O(1) | O(1) | Удаление сверху |
| peek | O(1) | O(1) | Просмотр верхнего элемента |
| isEmpty | O(1) | O(1) | Проверка пустоты |

### Пример

```javascript
class Stack {
  constructor() {
    this.items = [];
  }
  
  push(item) {
    this.items.push(item);
  }
  
  pop() {
    return this.items.pop();
  }
  
  peek() {
    return this.items[this.items.length - 1];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
}

// Использование
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.pop());  // 3 (последний добавленный)
```

---

## 4. Queue (Очередь)

### Описание

Очередь — это линейная структура данных, работающая по принципу **FIFO (First In, First Out)** — первый пришёл, первый ушёл. Как очередь в магазине.

### Операции

- **enqueue()** — добавить элемент в конец
- **dequeue()** — удалить элемент из начала
- **front()** — посмотреть первый элемент
- **isEmpty()** — проверить, пуста ли очередь

### Операции и сложность

| Операция | Queue | Array | Описание |
|----------|-------|-------|----------|
| Доступ | O(n) | O(1) | Доступ по индексу |
| Поиск | O(n) | O(n) | Линейный поиск |
| Вставка в конец | O(1) | O(1) | enqueue/push |
| Удаление с начала | O(1) | O(n) | dequeue vs shift |

### Пример

```javascript
class Queue {
  constructor() {
    this.items = [];
  }
  
  enqueue(item) {
    this.items.push(item);  // O(1)
  }
  
  dequeue() {
    return this.items.shift();  // O(n) в массиве
    // Для O(1) нужно использовать связный список
  }
  
  front() {
    return this.items[0];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
}

// Эффективная очередь с двумя стеками или связным списком
```

---

## 5. Set

### Описание

Set (Множество) — это коллекция уникальных элементов без повторений. В JavaScript реализован как хеш-таблица.

### Операции и сложность

| Операция | Время | Описание |
|----------|-------|----------|
| Добавление | O(1) | add() |
| Удаление | O(1) | delete() |
| Поиск | O(1) | has() |
| Обход | O(n) | forEach, for...of |

### Пример

```javascript
const set = new Set([1, 2, 3]);

set.add(4);        // O(1)
set.has(2);        // O(1) -> true
set.delete(3);     // O(1)
set.size;          // 3

// Уникальные значения из массива
const unique = [...new Set([1, 2, 2, 3, 3, 3])];  // [1, 2, 3]
```

---

## 6. Map / Hash Table (Хеш-таблица)

### Описание

Map (Словарь) — это структура данных, которая хранит пары ключ-значение. В JavaScript реализована как хеш-таблица с O(1) средним временем доступа.

### Операции и сложность

| Операция | Время | Описание |
|----------|-------|----------|
| Вставка | O(1) | set(key, value) |
| Поиск | O(1) | get(key) |
| Удаление | O(1) | delete(key) |
| Обход | O(n) | forEach, for...of |

### Пример

```javascript
const map = new Map();

map.set('name', 'John');     // O(1)
map.set('age', 30);          // O(1)
map.get('name');             // O(1) -> 'John'
map.has('age');              // O(1) -> true
map.delete('age');           // O(1)

// Итерация
for (const [key, value] of map) {
  console.log(key, value);
}

// Преобразование в объект
const obj = Object.fromEntries(map);
```

---

## 7. Binary Search Tree (Бинарное дерево поиска)

### Описание

Бинарное дерево поиска (BST) — это дерево, где каждый узел имеет максимум двух потомков, и для любого узла все значения в левом поддереве меньше, а в правом — больше значения узла.

### Операции и сложность

| Операция | Среднее | Худшее | Описание |
|----------|---------|--------|----------|
| Поиск | O(log n) | O(n) | Если дерево несбалансировано |
| Вставка | O(log n) | O(n) | Добавление узла |
| Удаление | O(log n) | O(n) | Удаление узла |
| Обход | O(n) | O(n) | In-order, Pre-order, Post-order |

**Примечание**: В худшем случае (вырожденное дерево) все операции O(n). Для гарантированного O(log n) нужны самобалансирующиеся деревья (AVL, Red-Black).

---

## 8. Graph (Граф)

### Описание

Граф — это структура данных, состоящая из вершин (nodes) и рёбер (edges), соединяющих эти вершины. Графы используются для моделирования связей между объектами.

### Типы графов

- **Направленный (Directed)** — рёбра имеют направление
- **Ненаправленный (Undirected)** — рёбра двунаправленные
- **Взвешенный (Weighted)** — рёбра имеют веса
- **Ациклический (DAG)** — без циклов

### Представление графа

#### 1. Матрица смежности

```javascript
// Для графа с n вершинами используется матрица n×n
const graph = [
  [0, 1, 1, 0],
  [1, 0, 1, 1],
  [1, 1, 0, 1],
  [0, 1, 1, 0]
];
// Сложность: O(n²) памяти, O(1) проверка связи
```

#### 2. Список смежности

```javascript
const graph = {
  0: [1, 2],
  1: [0, 2, 3],
  2: [0, 1, 3],
  3: [1, 2]
};
// Сложность: O(V + E) памяти, O(1) добавление, O(V) поиск
```

### Алгоритмы обхода

- **BFS (Breadth-First Search)** — обход в ширину
- **DFS (Depth-First Search)** — обход в глубину

---

## Сравнительная таблица структур данных

| Структура | Доступ | Поиск | Вставка | Удаление | Примечание |
|-----------|--------|-------|---------|----------|------------|
| Array | O(1) | O(n) | O(n) | O(n) | Быстрый доступ по индексу |
| Linked List | O(n) | O(n) | O(1)* | O(1)* | *В начало/конец |
| Stack | O(1) | - | O(1) | O(1) | Только верхний элемент |
| Queue | O(n) | O(n) | O(1) | O(1) | FIFO порядок |
| Set | - | O(1) | O(1) | O(1) | Уникальные значения |
| Map | O(1) | O(1) | O(1) | O(1) | Ключ-значение |
| BST | - | O(log n) | O(log n) | O(log n) | Сбалансированное дерево |
| Graph | - | O(V+E) | O(1) | O(E) | Зависит от представления |

---

*Для изучения алгоритмов работы со структурами данных см. [Patterns.md](./Patterns.md)*
*Для понимания сложности алгоритмов см. [Big O.md](./Big%20O.md)*
