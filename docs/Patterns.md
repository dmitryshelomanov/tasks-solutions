# Паттерны решения алгоритмических задач

## Полезные ресурсы

- [14 шаблонов для ответов на вопросы интервью](https://tproger.ru/translations/14-templates-to-answer-interview-questions)
- [Курсы по алгоритмам NeetCode](https://neetcode.io/courses/advanced-algorithms/0)

## Введение

При решении алгоритмических задач на собеседованиях и в реальной разработке существует набор проверенных паттернов (шаблонов), которые помогают структурированно подходить к решению. Понимание этих паттернов значительно ускоряет процесс поиска оптимального решения.

---

## Шаблоны

14 шаблонов, которые мы рассмотрим сегодня:

1. Скользящее окно.
2. Два Указателя или Итератора.
3. Быстрые и медленные Указатели или Итераторы.
4. Слияние интервалов.
5. Циклическая сортировка.
6. Разворот связанного списка.
7. Дерево BFS.
8. Дерево DFS.
9. Две кучи.
10. Подмножества.
11. Модифицированный бинарный поиск.
12. Топ К-элементов.
13. K-way слияние.
14. Топологическая сортировка.
15. Алгоритм кадане
16. Разделяй и властвуй


## 1. Скользящее окно (Sliding Window)

### Описание

Шаблон скользящего окна используется для выполнения операции с определённым размером окна данного массива или связанного списка. Например, для поиска самого длинного подмассива, содержащего все 1. 

Скользящие окна начинаются с первого элемента, продолжают смещаться вправо на один элемент и регулируют длину окна в соответствии с задачей, которую вы решаете. В некоторых случаях размер окна остаётся постоянным (фиксированное окно), а в других — увеличивается или уменьшается (динамическое окно).

### Когда использовать

- Входные данные задачи — это линейная структура данных (связанный список, массив или строка)
- Нужно найти самую длинную/короткую подстроку, подмассив или желаемое значение
- Задача связана с подмассивами или подстроками фиксированного или изменяемого размера

### План решения

1. Определить, окно динамическое или фиксированное
2. Проходим правым указателем (right pointer)
3. Делаем валидацию условий
4. Обновляем результат при необходимости

### Примеры задач

- **Лёгкий**: максимальная сумма подмассива размера «K»
- **Средний**: самая длинная подстрока с различными «K» символами
- **Сложный**: анаграммы строки

### Пример кода (фиксированное окно)

```javascript
function maxSumSubarray(arr, k) {
  let windowSum = 0;
  let maxSum = 0;
  
  // Инициализация окна
  for (let i = 0; i < k; i++) {
    windowSum += arr[i];
  }
  maxSum = windowSum;
  
  // Скольжение окна
  for (let i = k; i < arr.length; i++) {
    windowSum = windowSum - arr[i - k] + arr[i];
    maxSum = Math.max(maxSum, windowSum);
  }
  
  return maxSum;
}
```

## 2. Два указателя или итератора (Two Pointers)

### Описание

Это шаблон, в котором два указателя перебирают структуру данных в тандеме, пока один или оба указателя не достигнут определённого условия. Два указателя часто полезны при поиске пар в отсортированном массиве или связанном списке.

С одним указателем пришлось бы постоянно возвращаться назад через массив, чтобы найти ответ. Хотя решение в лоб с одним указателем будет работать, его сложность составляет O(n²). Два указателя помогают найти решение с лучшей временной и пространственной сложностью O(n).

### Когда использовать

- Вы имеете дело с отсортированными массивами (или связанными списками)
- Вам необходимо найти набор элементов, которые удовлетворяют определённым ограничениям
- Набор элементов в массиве представляет собой пару, триплет или даже подмассив

### Примеры задач

- **Лёгкий**: возведение в квадрат отсортированного массива
- **Средний**: триплеты, суммирующие до нуля
- **Средний**: сравнение строк, содержащих пробелы

### Пример кода

```javascript
function twoSumSorted(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left < right) {
    const sum = arr[left] + arr[right];
    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return [];
}
```

## 3. Быстрые и медленные указатели (Fast & Slow Pointers)

### Описание

Подход быстрого и медленного указателя, также известный как **алгоритм зайца и черепахи** (Floyd's Cycle Detection), использует два указателя, которые перемещаются по массиву (или последовательности / связному списку) с разными скоростями.

Двигаясь с разными скоростями (обычно быстрый указатель двигается в 2 раза быстрее медленного), алгоритм доказывает, что эти два указателя обязательно встретятся, если существует цикл. Быстрый указатель перехватывает медленный, когда оба указателя находятся в цикле.

### Когда использовать

- Задача касается цикла в связанном списке или массиве
- Нужно узнать положение определённого элемента или общую длину связанного списка
- Определение середины связанного списка
- Проверка, является ли связанный список палиндромом

### Когда использовать вместо двух указателей

Используйте быстрые и медленные указатели вместо обычных двух указателей, когда:
- Вы работаете с одним списком и не можете двигаться в обратном направлении
- Нужно определить наличие цикла или найти середину списка
- Обычные два указателя (left/right) не применимы

### Примеры задач

- **Лёгкий**: цикл связанного списка (определение наличия цикла)
- **Средний**: является ли связанный список палиндромом
- **Сложный**: цикл в круговом массиве

### Пример кода (определение цикла)

```javascript
function hasCycle(head) {
  if (!head || !head.next) return false;
  
  let slow = head;
  let fast = head.next;
  
  while (fast && fast.next) {
    if (slow === fast) return true;
    slow = slow.next;
    fast = fast.next.next;
  }
  
  return false;
}
```

## 4. Слияние интервалов (Merge Intervals)

### Описание

Эффективный метод работы с пересекающимися интервалами. В большинстве задач, связанных с интервалами, нужно либо найти пересекающиеся интервалы, либо совместить интервалы, если они пересекаются.

Для двух интервалов (a и b) существует шесть основных случаев их взаимодействия:

1. a полностью перед b (не пересекаются)
2. a перекрывает начало b
3. a полностью внутри b
4. a полностью содержит b
5. a перекрывает конец b
6. a полностью после b (не пересекаются)

Понимание этих случаев позволит решить широкий спектр задач — от вставки интервалов до оптимизации слияний интервалов.

### Когда использовать

- Нужно составить список только с взаимоисключающими интервалами
- Вы слышите термин «пересекающиеся интервалы»
- Работа с временными интервалами, периодами, диапазонами

### Примеры задач

- **Средний**: пересечение интервалов
- **Сложный**: максимальная нагрузка на процессор

### Пример кода

```javascript
function mergeIntervals(intervals) {
  if (intervals.length <= 1) return intervals;
  
  // Сортируем интервалы по началу
  intervals.sort((a, b) => a[0] - b[0]);
  
  const merged = [intervals[0]];
  
  for (let i = 1; i < intervals.length; i++) {
    const current = intervals[i];
    const lastMerged = merged[merged.length - 1];
    
    // Если текущий интервал пересекается с последним объединённым
    if (current[0] <= lastMerged[1]) {
      lastMerged[1] = Math.max(lastMerged[1], current[1]);
    } else {
      merged.push(current);
    }
  }
  
  return merged;
}
```

## 5. Циклическая сортировка (Cycle Sort)

### Описание

Интересный подход для решения задач, которые связаны с массивами, содержащими числа в заданном диапазоне. Шаблон циклической сортировки выполняет итерацию по массиву по одному числу за раз.

Если текущее число не соответствует правильному индексу, вы меняете его местами с числом по правильному индексу. Затем повторяете процесс для числа, которое было на этом индексе, пока не образуется цикл.

Ключевое преимущество: каждое число перемещается на своё место максимум один раз, что даёт сложность O(n).

### Когда использовать

- В задачах с использованием массива с числами в заданном диапазоне (обычно от 1 до n)
- Если нужно найти отсутствующее/дублированное/наименьшее число
- Когда требуется сортировка in-place с минимальным количеством операций записи

### Примеры задач

- **Лёгкий**: найти недостающий номер
- **Средний**: найти наименьшее недостающее положительное число

### Пример кода

```javascript
function findMissingNumber(nums) {
  let i = 0;
  const n = nums.length;
  
  // Циклическая сортировка
  while (i < n) {
    const correctIndex = nums[i];
    if (nums[i] < n && nums[i] !== nums[correctIndex]) {
      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];
    } else {
      i++;
    }
  }
  
  // Находим отсутствующее число
  for (let i = 0; i < n; i++) {
    if (nums[i] !== i) {
      return i;
    }
  }
  
  return n;
}
```

## 6. Разворот связанного списка (Reverse Linked List)

### Описание

Инвертирование связей между набором узлов связанного списка. Часто это нужно сделать на месте (in-place), используя существующие объекты узла без дополнительной памяти.

Шаблон меняет связи узлов по одному, используя:
- `current` — указывает на текущий обрабатываемый узел
- `previous` — указывает на предыдущий узел, который уже обработан
- `next` — сохраняет следующий узел перед изменением связей

Шаг за шагом вы разворачиваете узел, наводя его на предыдущий, прежде чем перейти к следующему узлу.

### Когда использовать

- Если вас попросили развернуть связанный список без использования дополнительной памяти
- Реверсирование части списка
- Связанные задачи с изменением порядка узлов

### Примеры задач

- **Лёгкий**: перевернуть весь связанный список
- **Средний**: перевернуть подсписок
- **Средний**: перевернуть каждый K-элемент подсписка

### Пример кода (итеративный)

```javascript
function reverseList(head) {
  let previous = null;
  let current = head;
  
  while (current !== null) {
    const next = current.next;  // Сохраняем следующий узел
    current.next = previous;     // Меняем связь
    previous = current;          // Перемещаем previous
    current = next;              // Перемещаем current
  }
  
  return previous;  // previous теперь указывает на новый head
}
```

### Пример кода (рекурсивный)

```javascript
function reverseListRecursive(head) {
  if (!head || !head.next) return head;
  
  const newHead = reverseListRecursive(head.next);
  head.next.next = head;
  head.next = null;
  
  return newHead;
}
```

## 7. Дерево BFS (Breadth-First Search)

### Описание

Этот шаблон основан на методе **поиска в ширину (BFS)** для обхода дерева и использует очередь для отслеживания всех узлов уровня перед переходом на следующий уровень.

BFS работает, помещая корневой узел в очередь, а затем непрерывно повторяясь, пока очередь не станет пустой. Для каждой итерации:
1. Удаляем узел в начале очереди
2. «Посещаем» этот узел (обрабатываем)
3. Вставляем все его дочерние элементы в очередь

Это гарантирует, что мы обработаем все узлы уровня перед переходом на следующий уровень.

### Когда использовать

- Вас просят обойти дерево поуровнево (level-order traversal)
- Нужно найти кратчайший путь в дереве
- Задачи, связанные с уровнями дерева

### Примеры задач

- **Лёгкий**: поуровневый обход двоичного дерева
- **Средний**: зигзагообразный обход
- **Средний**: найти максимальную ширину уровня

### Пример кода

```javascript
function levelOrder(root) {
  if (!root) return [];
  
  const result = [];
  const queue = [root];
  
  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];
    
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    
    result.push(currentLevel);
  }
  
  return result;
}
```

## 8. Дерево DFS (Depth-First Search)

### Описание

Дерево DFS основано на методе **поиска в глубину (DFS)** для обхода дерева. Можно использовать рекурсию (или стек для итеративного подхода), чтобы отслеживать все предыдущие (родительские) узлы при обходе.

DFS работает начиная с корня дерева. Если узел не является листом, нужно:

1. Решить, обрабатывать ли текущий узел:
   - **Прямой обход (Pre-order)**: обрабатываем узел до дочерних
   - **Центрированный обход (In-order)**: обрабатываем узел между левым и правым поддеревом
   - **Обратный обход (Post-order)**: обрабатываем узел после дочерних

2. Сделать рекурсивные вызовы для потомков текущего узла

### Когда использовать

- Вас просят совершить прямой, центрированный или обратный обход дерева
- Требуется найти что-то, где узел ближе к листу
- Задачи, связанные с путями от корня к листьям
- Когда нужна информация о поддеревьях перед обработкой родителя

### Примеры задач

- **Средний**: сумма номеров путей
- **Средний**: все пути для суммы
- **Средний**: максимальная глубина дерева

### Пример кода (Pre-order)

```javascript
function preOrder(root, result = []) {
  if (!root) return result;
  
  result.push(root.val);           // Обрабатываем узел
  preOrder(root.left, result);     // Левый потомок
  preOrder(root.right, result);    // Правый потомок
  
  return result;
}
```

### Пример кода (In-order)

```javascript
function inOrder(root, result = []) {
  if (!root) return result;
  
  inOrder(root.left, result);      // Левый потомок
  result.push(root.val);           // Обрабатываем узел
  inOrder(root.right, result);     // Правый потомок
  
  return result;
}
```

### Пример кода (Post-order)

```javascript
function postOrder(root, result = []) {
  if (!root) return result;
  
  postOrder(root.left, result);    // Левый потомок
  postOrder(root.right, result);   // Правый потомок
  result.push(root.val);           // Обрабатываем узел
  
  return result;
}
```

## 9. Две кучи (Two Heaps)

### Описание

Во многих задачах дан набор элементов, которые можно разделить на две части. Чтобы решить задачу, нужно знать наименьший элемент в одной части и наибольший в другой.

Этот шаблон использует две кучи:
- **Max Heap** — для хранения меньшей половины чисел (наибольший элемент легко доступен)
- **Min Heap** — для хранения большей половины чисел (наименьший элемент легко доступен)

Шаблон работает, сохраняя первую половину чисел в Max Heap, потому что вы ищете наибольшее число в первой половине. Затем вы сохраняете вторую половину чисел в Min Heap, так как хотите найти наименьшее число во второй половине.

В любой момент медиана текущего списка чисел может быть вычислена из верхних элементов двух куч.

### Когда использовать

- Приоритетные очереди, планирование
- Нужно найти самые маленькие / самые большие / медианные элементы набора
- Динамические задачи поиска медианы
- Иногда полезен в задачах с бинарной структурой данных

### Примеры задач

- **Средний**: найти медиану потока чисел
- **Средний**: найти максимум в скользящем окне

### Пример кода (медиана потока)

```javascript
class MedianFinder {
  constructor() {
    this.maxHeap = []; // Меньшая половина
    this.minHeap = []; // Большая половина
  }
  
  addNum(num) {
    if (this.maxHeap.length === 0 || num <= this.maxHeap[0]) {
      this.maxHeap.push(num);
      this.maxHeap.sort((a, b) => b - a);
    } else {
      this.minHeap.push(num);
      this.minHeap.sort((a, b) => a - b);
    }
    
    // Балансировка
    if (this.maxHeap.length > this.minHeap.length + 1) {
      this.minHeap.push(this.maxHeap.shift());
      this.minHeap.sort((a, b) => a - b);
    } else if (this.minHeap.length > this.maxHeap.length) {
      this.maxHeap.push(this.minHeap.shift());
      this.maxHeap.sort((a, b) => b - a);
    }
  }
  
  findMedian() {
    if (this.maxHeap.length === this.minHeap.length) {
      return (this.maxHeap[0] + this.minHeap[0]) / 2;
    }
    return this.maxHeap[0];
  }
}
```

## 10. Подмножества (Subsets)

### Описание

Огромное количество задач на собеседовании связано с перестановками и комбинациями заданного набора элементов. Шаблон подмножества описывает эффективный метод поиска в ширину (BFS) для их решения.

**Алгоритм построения подмножеств:**

Дан набор из `[1, 5, 3]`:

1. Начните с пустого набора: `[[]]`
2. Добавьте первое число (1) ко всем существующим подмножествам: `[[], [1]]`
3. Добавьте второе число (5) ко всем существующим подмножествам: `[[], [1], [5], [1,5]]`
4. Добавьте третье число (3) ко всем существующим подмножествам: `[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]`

Каждый новый элемент добавляется ко всем существующим подмножествам, создавая новые комбинации.

### Когда использовать

- Нужно найти комбинации или перестановки заданного набора
- Генерация всех возможных подмножеств
- Задачи с комбинаторным поиском

### Примеры задач

- **Лёгкий**: подмножества с дубликатами
- **Средний**: перестановки строк при изменении регистра
- **Средний**: все возможные перестановки

### Пример кода

```javascript
function subsets(nums) {
  const result = [[]];
  
  for (const num of nums) {
    const newSubsets = [];
    for (const subset of result) {
      newSubsets.push([...subset, num]);
    }
    result.push(...newSubsets);
  }
  
  return result;
}

// Альтернативный рекурсивный подход
function subsetsRecursive(nums) {
  const result = [];
  
  function backtrack(start, current) {
    result.push([...current]);
    
    for (let i = start; i < nums.length; i++) {
      current.push(nums[i]);
      backtrack(i + 1, current);
      current.pop();
    }
  }
  
  backtrack(0, []);
  return result;
}
```

## Модифицированный бинарный поиск

Когда вам дают отсортированный массив, связанный список или матрицу и просят найти определённый элемент, лучшим алгоритмом будет бинарный поиск. Этот шаблон описывает эффективный способ решения всех задач, связанных с бинарным поиском.
Для набора по возрастанию шаблоны выглядят так:

1. Сначала найдите середину начала и конца. Простой способ найти середину был бы: middle = (start + end) / 2. Но от этого может быть целочисленное переполнение, поэтому рекомендуется представлять середину как: middle = start + (end – start) / 2.
2. Если ключ равен числу в середине индекса, верните середину.
3. Если «ключ» не равен середине индекса:Если ключ < arr [middle], уменьшите поиск до end = middle — 1.Если ключ > arr [middle], уменьшите поиск до to end = middle + 1.

Наглядное представление шаблона модифицированный бинарный поиск:

Задачи, для которых подойдёт шаблон модифицированный бинарный поиск:

- Бинарный поиск, не зависящий от порядка (лёгкий);
- Поиск в отсортированном бесконечном массиве (средний).

## Топ К-элементов

Любая задача, в которой требуется найти самые большие / самые маленькие / частые K-элементы среди данного набора, подпадает под этот шаблон.
Лучшая структура данных для отслеживания K-элементов — куча. Этот шаблон будет использовать кучу для решения задач, связанных с K-элементами одновременно из набора заданных элементов. Шаблон выглядит так:

1. Вставьте K-элементы в Min-heap или Max-heap в зависимости от задачи.
2. Выполните итерации по оставшимся числам и, если найдёте число, которое больше, чем у вас в куче, удалите это число и вставьте большее.

Нет необходимости в алгоритме сортировки, потому что куча будет отслеживать элементы для вас.
Как определить, когда использовать шаблон Топ К-элементов:

- если нужно найти самые большие / самые маленькие / частые K-элементы в данном наборе;
- если нужно отсортировать массив, чтобы найти верный элемент.

Задачи, для которых подойдёт шаблон Топ К-элементов:

- топ K-номеров (лёгкий);
- топ K-частых номеров (средний).

## 13. K-way слияние (K-way Merge)

### Описание

K-way слияние помогает решить задачи, связанные с набором отсортированных массивов или списков.

Когда вам дают отсортированные K-массивов, вы можете использовать кучу для эффективного выполнения отсортированного обхода всех элементов всех массивов. Поместите наименьший элемент каждого массива в Min Heap, чтобы получить общий минимум. После извлечения минимального элемента поместите следующий элемент из того же массива в кучу. Повторите процесс для отсортированного обхода всех элементов.

**Алгоритм:**

1. Вставьте первый элемент каждого массива в Min Heap (вместе с информацией о массиве)
2. Извлеките самый маленький элемент из кучи и добавьте в объединённый список
3. После удаления наименьшего элемента вставьте следующий элемент из того же массива в кучу
4. Повторите шаги 2 и 3, пока куча не опустеет

### Когда использовать

- Задача состоит из отсортированных массивов, списков или матрицы
- Требуется объединить отсортированные списки
- Нужно найти самый маленький элемент среди нескольких отсортированных источников

### Примеры задач

- **Средний**: слияние K-сортированных списков
- **Сложный**: K-пары с самыми большими суммами
- **Средний**: найти K-й наименьший элемент в отсортированной матрице

### Пример кода

```javascript
function mergeKLists(lists) {
  const minHeap = [];
  
  // Добавляем первые элементы всех списков в кучу
  for (let i = 0; i < lists.length; i++) {
    if (lists[i]) {
      minHeap.push({ val: lists[i].val, listIndex: i, node: lists[i] });
    }
  }
  
  minHeap.sort((a, b) => a.val - b.val);
  
  const dummy = { next: null };
  let current = dummy;
  
  while (minHeap.length > 0) {
    const { val, listIndex, node } = minHeap.shift();
    
    current.next = { val, next: null };
    current = current.next;
    
    // Добавляем следующий элемент из того же списка
    if (node.next) {
      minHeap.push({ 
        val: node.next.val, 
        listIndex, 
        node: node.next 
      });
      minHeap.sort((a, b) => a.val - b.val);
    }
  }
  
  return dummy.next;
}
```

## 14. Топологическая сортировка (Topological Sort)

### Описание

Топологическая сортировка используется для нахождения линейного порядка элементов, которые зависят друг от друга (Directed Acyclic Graph - DAG). Например, если событие «Б» зависит от события «A», то «A» предшествует «Б» в топологическом порядке.

Этот шаблон применяет алгоритм **Kahn's algorithm** для выполнения топологической сортировки.

**Алгоритм:**

1. **Инициализация**: 
   - Храните граф в списках смежности (HashMap)
   - Используйте HashMap для сохранения количества входящих рёбер (in-degree) для каждой вершины

2. **Постройте граф и найдите степени всех вершин**:
   - Постройте граф из входных данных
   - Заполните HashMap степенями (in-degrees)

3. **Найдите все источники**:
   - Все вершины с in-degree = 0 будут источниками
   - Поместите их в очередь

4. **Сортировка**:
   - Для каждого источника:
     - Добавьте его в отсортированный список
     - Получите все дочерние элементы из графа
     - Уменьшите in-degree каждого дочернего элемента на 1
     - Если in-degree дочернего элемента становится 0, добавьте его в очередь источников
   - Повторяйте, пока очередь не станет пустой

### Когда использовать

- Задача связана с графами без направленных циклов (DAG)
- Нужно обновить все объекты в отсортированном порядке зависимостей
- Есть класс объектов, которые следуют определённому порядку
- Задачи планирования с зависимостями

### Примеры задач

- **Средний**: поиск порядка выполнения задач с зависимостями
- **Средний**: построение графика курсов с предварительными требованиями
- **Сложный**: компиляция модулей с зависимостями

### Пример кода

```javascript
function topologicalSort(numCourses, prerequisites) {
  const graph = {};
  const inDegree = new Array(numCourses).fill(0);
  
  // Построение графа и подсчёт in-degree
  for (const [course, prereq] of prerequisites) {
    if (!graph[prereq]) graph[prereq] = [];
    graph[prereq].push(course);
    inDegree[course]++;
  }
  
  // Находим все источники (in-degree = 0)
  const queue = [];
  for (let i = 0; i < numCourses; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }
  
  const result = [];
  
  // Обработка вершин
  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node);
    
    if (graph[node]) {
      for (const neighbor of graph[node]) {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      }
    }
  }
  
  // Если есть цикл, результат будет неполным
  return result.length === numCourses ? result : [];
}
```

## 15. Алгоритм Кадане (Kadane's Algorithm)

### Описание

Алгоритм Кадане используется для нахождения максимальной суммы подмассива (подпоследовательности подряд идущих элементов) в массиве.

**Ключевая идея:** Для каждой позиции получаем максимальную сумму подмассива, заканчивающегося в этой позиции. Ответ — это максимум по всем таким позициям.

Алгоритм работает за O(n) времени и O(1) дополнительной памяти, что делает его очень эффективным.

### Когда использовать

- Нужно найти максимальную сумму подмассива
- Задачи, связанные с непрерывными подпоследовательностями
- Когда нужна линейная сложность O(n)

### Примеры задач

- **Лёгкий**: максимальная сумма подмассива
- **Средний**: максимальная сумма подмассива с возможностью одного удаления
- **Сложный**: максимальная сумма подматрицы

### Пример кода (базовая версия)

```javascript
function maxSubarraySum(nums) {
  let maxSum = nums[0];
  let currentSum = nums[0];
  
  for (let i = 1; i < nums.length; i++) {
    // Либо продолжаем предыдущий подмассив, либо начинаем новый
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
  }
  
  return maxSum;
}
```

### Пример кода (с возвратом индексов)

```javascript
function maxSubarraySumWithIndices(nums) {
  let maxSum = nums[0];
  let currentSum = nums[0];
  let start = 0;
  let end = 0;
  let tempStart = 0;
  
  for (let i = 1; i < nums.length; i++) {
    if (currentSum < 0) {
      currentSum = nums[i];
      tempStart = i;
    } else {
      currentSum += nums[i];
    }
    
    if (currentSum > maxSum) {
      maxSum = currentSum;
      start = tempStart;
      end = i;
    }
  }
  
  return { sum: maxSum, start, end, subarray: nums.slice(start, end + 1) };
}
```

## 16. Разделяй и властвуй (Divide and Conquer)

### Описание

**Разделяй и властвуй** — это парадигма алгоритма, основанная на многоуровневой рекурсии.

**Основная идея:**
1. **Разделяй** (Divide): разбейте задачу на подзадачи того же типа
2. **Властвуй** (Conquer): решите подзадачи рекурсивно
3. **Объединяй** (Combine): объедините решения подзадач для получения решения исходной задачи

Для рекурсии базовый случай — это обычно массив из 1 элемента или пустой массив.

### Когда использовать

- Задача может быть разбита на независимые подзадачи
- Подзадачи того же типа, что и исходная задача
- Решения подзадач можно объединить для решения исходной задачи
- Когда нужна временная сложность O(n log n) или лучше

### Пример: Максимальная сумма подмассива

**Алгоритм:**
1. Делим массив на 2 части (левую и правую)
2. Ищем максимальную сумму в каждой половине рекурсивно
3. Ищем максимальную сумму, пересекающую границу:
   - Для левой части: максимальная сумма на **суффиксе** (от середины влево)
   - Для правой части: максимальная сумма на **префиксе** (от середины вправо)
   - Объединяем: суффикс + префикс
4. Возвращаем максимум из трёх: левая половина, правая половина, через границу

### Примеры задач

- **Средний**: максимальная сумма подмассива (Divide and Conquer)
- **Средний**: сортировка слиянием (Merge Sort)
- **Средний**: быстрая сортировка (Quick Sort)
- **Сложный**: число инверсий в массиве

### Пример кода

```javascript
function maxSubarraySumDivideConquer(nums) {
  function maxCrossingSum(arr, left, mid, right) {
    // Максимальная сумма на суффиксе левой части
    let leftSum = -Infinity;
    let sum = 0;
    for (let i = mid; i >= left; i--) {
      sum += arr[i];
      leftSum = Math.max(leftSum, sum);
    }
    
    // Максимальная сумма на префиксе правой части
    let rightSum = -Infinity;
    sum = 0;
    for (let i = mid + 1; i <= right; i++) {
      sum += arr[i];
      rightSum = Math.max(rightSum, sum);
    }
    
    return leftSum + rightSum;
  }
  
  function maxSubarraySumHelper(arr, left, right) {
    // Базовый случай
    if (left === right) {
      return arr[left];
    }
    
    const mid = Math.floor((left + right) / 2);
    
    // Максимум в левой половине
    const leftMax = maxSubarraySumHelper(arr, left, mid);
    
    // Максимум в правой половине
    const rightMax = maxSubarraySumHelper(arr, mid + 1, right);
    
    // Максимум через границу
    const crossMax = maxCrossingSum(arr, left, mid, right);
    
    return Math.max(leftMax, rightMax, crossMax);
  }
  
  return maxSubarraySumHelper(nums, 0, nums.length - 1);
}
```

### Сравнение с другими подходами

- **Кадане (Kadane)**: O(n) времени, O(1) памяти — оптимальнее для этой задачи
- **Разделяй и властвуй**: O(n log n) времени, O(log n) памяти — демонстрирует общий подход
